---
title: "PER Aim One Analyses"
author: "Ian Kahrilas"
date: "5/15/2020"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(lmerTest)
library(here)
library(ggpubr)
library(car)
library(emmeans)
library(easystats)
library(welchADF)
library(moments)
library(modelbased)
library(patchwork)
library(report)
library(r2glmm)
# load in data
per_dat <- read_csv(here("data", "created_data", "per_data_analyses_2020_5_15.csv"))
```

# Characterizing relationship between block conditions and EEG components

## Passive conditions and LPP

```{r LPP by passive block, warning=FALSE, message=FALSE}
# box and whisker plots for LPP
per_dat %>% 
  filter(block %in% c("Neg_Watch", "Neu_Watch", "Pos_Watch")) %>% 
  mutate(block = fct_relevel(block, c("Neg_Watch", 
                                      "Neu_Watch",
                                      "Pos_Watch"))) %>% # Change block order
  ggplot(., aes(block, LPP)) +
  geom_boxplot() + 
  ggtitle("LPP box and whisker plots for passive blocks")

per_dat$block <- relevel(as.factor(per_dat$block), "Neu_Watch")
passive_lpp_mod <- lmer(LPP ~ block + (1|pid), data = per_dat %>% filter(block %in% c("Neg_Watch", "Neu_Watch", "Pos_Watch")))
# check the quality of the model
check_model(passive_lpp_mod, panel = FALSE)
summary(passive_lpp_mod)
r2beta(passive_lpp_mod)
```

There are significant differences in LPP for each passive block

## Passive conditions and late LPP

```{r late LPP and passive blocks}
# box and whisker plots for late LPP and passive blocks
per_dat %>% 
  filter(block %in% c("Neg_Watch", "Neu_Watch", "Pos_Watch")) %>% 
  mutate(block = fct_relevel(block, c("Neg_Watch",
                                      "Neu_Watch",
                                      "Pos_Watch"))) %>% # Change block order
  ggplot(., aes(block, LPP_late)) +
  geom_boxplot() + 
  ggtitle("Late LPP box and whisker plots for each block")

passive_late_lpp_mod <- lmer(LPP_late ~ block + (1|pid), data = per_dat %>% filter(block %in% c("Neg_Watch", "Neu_Watch", "Pos_Watch")))
# check the quality of the model
check_model(passive_late_lpp_mod, panel = FALSE)
summary(passive_late_lpp_mod)
r2beta(passive_late_lpp_mod)
```

## Passive conditions and EPN (right and left)

```{r}
# create dataset with lateralization variable
tmp <- per_dat %>% 
  pivot_longer(c("EPN_left", "EPN_right"), names_to = "lateralization", names_prefix = "EPN_", values_to = "EPN") %>% 
  select(-c(front_right, front_left))
tmp2 <- per_dat %>% 
  pivot_longer(c("front_left", "front_right"), names_to = "lateralization", names_prefix = "front_", values_to = "frontal") %>% 
  select(pid, block, frontal, lateralization)
per_dat_lat <- left_join(tmp, tmp2, by = c("pid", "block", "lateralization")) %>% 
  select(pid:LPP_late, EPN, frontal, lateralization, everything())

# box and whisker plots for EPN
per_dat_lat %>% 
  filter(block %in% c("Neg_Watch", "Neu_Watch", "Pos_Watch")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right")), # lateralization order
         block = fct_relevel(block, c("Neg_Watch",
                                      "Neu_Watch",
                                      "Pos_Watch"))) %>% # Change block order 
  ggplot(., aes(block, EPN, color = lateralization)) +
  geom_boxplot() +
  ggtitle("EPN box and whisker plots for each block")


per_erp_rev %>% 
  ggplot(., aes(block, LPP)) + 
  geom_boxplot() + 
  ggtitle("Centroparietal LPP box and whisker plots for each block")
per_erp_filter_lat %>% 
  filter(lateralization %in% c("left", "right")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right")), # lateralization order
         block = fct_relevel(block, c("Neg_Inc", "Neg_Watch", "Neg_Dec",
                                      "Neu_Watch",
                                      "Pos_Dec", "Pos_Watch", "Pos_Inc"))) %>% # Change block order 
  ggplot(., aes(block, front_avr, color = lateralization)) +
  geom_boxplot() +
  ggtitle("Frontal component box and whisker plots for each block") # omit midline condition
```



## Contrasts between conditions

```{r contrasts, message = FALSE, warning = FALSE}
# relevel factor variables
per_erp_filter_lat$block <- relevel(as.factor(per_erp_filter_lat$block), "Neu_Watch")
per_erp_filter_lat$lateralization <- factor(per_erp_filter_lat$lateralization, levels = c("left", "avg", "right"))
per_erp_rev$block <- relevel(as.factor(per_erp_rev$block), "Neu_Watch")
per_erp_filter_lat <- per_erp_filter_lat %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "avg", "right")))

# filtered LPP
block_mod_lpp_filter <- lmerTest::lmer(LPP ~ block*lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
summary(block_mod_lpp_filter)
# performance::check_model(block_mod_lpp_filter, panel = FALSE)
## LPP contrasts
emmeans(block_mod_lpp_filter, pairwise ~ lateralization | block)$contrasts
emmeans(block_mod_lpp_filter, pairwise ~ block | lateralization)$contrasts
means_block_lpp_filter <- emmeans(block_mod_lpp_filter, pairwise ~ lateralization | block)
emmip(block_mod_lpp_filter, block ~ lateralization) +
  ggtitle("LPP Lateralization Contrasts")# plot
## for interaction terms as well
block_lpp_filter_df <- as.data.frame(emmeans(block_mod_lpp_filter, pairwise ~ lateralization * block ))
block_lpp_filter_df
# No remarkable differences in lateralization here.

# EPN
block_mod_epn_filter <- lmerTest::lmer(EPN ~ block*lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
summary(block_mod_epn_filter)
# performance::check_model(block_mod_epn_filter, panel = FALSE)
## EPN contrasts
emmeans(block_mod_epn_filter, pairwise ~ lateralization | block)$contrasts
emmeans(block_mod_epn_filter, pairwise ~ block | lateralization)$contrasts
means_block_epn <- emmeans(block_mod_epn_filter, pairwise ~ lateralization | block)
emmip(block_mod_epn_filter, block ~ lateralization) +
  ggtitle("EPN Lateralization Contrasts") # plot
## for interaction terms as well
block_epn_filter_df <- as.data.frame(emmeans(block_mod_epn_filter, pairwise ~ lateralization * block ))
# for EPN, seeing significant differences in lateralization (right > left) for Neg_Dec, Pos_Dec, Pos_Inc) and others that are trending

# frontal avr
block_mod_front_avr_fil <- lmerTest::lmer(front_avr ~ block * lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(block_mod_front_avr_fil)
emmeans(block_mod_front_avr_fil, pairwise ~ block | lateralization)$contrasts
# due to overly stringent p-value adjustment, some differences aren't signficant. However, there are noticeable effects
# for pos watch - pos inc in the right hemisphere and neg watch - neg dec in the left.

#---- all possible block contrasts for average conditions
mod_avg_lpp <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
emmeans(mod_avg_lpp, pairwise ~ block)$contrasts
mod_avg_epn <- lmerTest::lmer(EPN ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
emmeans(mod_avg_epn, pairwise ~ block)$contrasts

# revised lpp
block_mod_lpp_rev <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_rev)
summary(block_mod_lpp_rev)
emmeans(block_mod_lpp_rev, pairwise ~ block)
```


## Aim One: Passive Blocks

```{r hypothesis one, message=FALSE}
# function for deriving Wald confidence intervals for robust models
confint.rlmerMod <- function(object,parm,level=0.95) {
  beta <- fixef(object)
  if (missing(parm)) parm <- names(beta)
  se <- sqrt(diag(vcov(object)))
  z <- qnorm((1+level)/2)
  ctab <- cbind(beta-z*se,beta+z*se)
  colnames(ctab) <- stats:::format.perc(c((1-level)/2,(1+level)/2),
                                        digits=3)
  return(ctab[parm,])
}

# fit null model for LPP
null_lpp_model <- lmer(LPP ~ (1|pid), data = filter(per_erp_filter_lat, lateralization == "avg"))
# check intraclass correlation
performance::icc(null_lpp_model)
# 42.9% of the variance in LPP can be explained by between-participant effects.
# relevel block variable
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
# fit model one
mod_one <- lmerTest::lmer(LPP ~ block + (1|pid), data = filter(per_erp_filter_lat, lateralization == "avg"))
# check assumptions
check_model(mod_one)
summary(mod_one)
report(mod_one) # APA style reporting
r2beta(mod_one) # semi-partial R2
# fit model one, but with epn as outcome
# ICC
null_epn_model <- lmer(EPN ~ (1|pid), data = filter(per_erp_filter_lat, lateralization == "avg"))
icc(null_epn_model)
# 76.5% of the  variance in EPN can be explained by between-participant effects
# fit model one with EPN
mod_one_epn <- lmerTest::lmer(EPN ~ block + lateralization + (1|pid), data = per_erp_filter_lat  %>% filter(lateralization %in% c("right", "left")))
# check assumptions
check_model(mod_one_epn)
summary(mod_one_epn)
report(mod_one_epn)
r2beta(mod_one_epn)
# add in lateralization interaction term
mod_one_epn_lat <- lmerTest::lmer(EPN ~ block * lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
summary(mod_one_epn_lat)
report(mod_one_epn_lat)

# frontal avr as outcome
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
null_front_avr <- lmerTest::lmer(front_avr ~ (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
icc(null_front_avr)
# model one
mod_one_front_avr_left_fil <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
mod_one_front_avr_right_fil <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
check_model(mod_one_front_avr_left_fil, panel = FALSE)
check_model(mod_one_front_avr_right_fil, panel = FALSE)
summary(mod_one_front_avr_left_fil)
summary(mod_one_front_avr_right_fil)

# frontal mast as outcome
# model one with filtered dataset
mod_one_front_mast_right_fil <- lmerTest::lmer(front_mast ~ block + (1|pid), per_erp_filter_lat %>% filter(lateralization == "right"))
mod_one_front_mast_left_fil <- lmerTest::lmer(front_mast ~ block + (1|pid), per_erp_filter_lat %>% filter(lateralization == "left"))
check_model(mod_one_front_mast_right_fil, panel = FALSE)
check_model(mod_one_front_mast_left_fil, panel = FALSE)
summary(mod_one_front_mast_right_fil)
summary(mod_one_front_mast_left_fil)

# revised lpp as outcome
null_lpp_rev <- lmerTest::lmer(LPP ~ (1|pid), data = per_erp_rev)
icc(null_lpp_rev)
# 36.6% of the variance is accounted for by between participant differences
mod_one_lpp_rev <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_rev)
check_model(mod_one_lpp_rev)
summary(mod_one_lpp_rev)
```

## Aim 1B: Regulation blocks
```{r regulation blocks}
# LPP
## relevel block variable and inspect negative regulation blocks
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch") 
## fit model
mod_one_lpp_neg <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
check_model(mod_one_neg, panel = FALSE)
summary(mod_one_lpp_neg)
## relevel block variable and inspect positive regulation blocks
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_one_lpp_pos <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right", "left")))
summary(mod_one_lpp_pos)

# EPN
## relevel block variable and inspect negative regulation blocks
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
## fit model
mod_one_epn_neg <- lmerTest::lmer(EPN ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_one_epn_neg)

## relevel block variable and inspect positive regulation blocks
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_one_epn_pos <- lmerTest::lmer(EPN ~ block + lateralization + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(mod_one_epn_pos)
## see if there's a three-way interaction with lateralization
mod_one_pos_lat <- lmerTest::lmer(EPN ~ block * lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
summary(mod_one_pos_lat)

# now with the revised LPP selection
## relevel block variable to test negative regulation conditions
per_erp_rev$block <- relevel(per_erp_rev$block, "Neg_Watch")
mod_one_neg_lpp_rev <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_rev)
check_model(mod_one_neg_lpp_rev, panel = FALSE)
summary(mod_one_neg_lpp_rev)
## try with robust model
mod_one_neg_lpp_rev_rob <- rlmer(LPP ~ block + (1|pid), data = per_erp_rev)
summary(mod_one_neg_lpp_rev_rob)
confint.rlmerMod(mod_one_neg_lpp_rev_rob)
## relevel block variable to test positive regulation conditions
per_erp_rev$block <- relevel(per_erp_rev$block, "Pos_Watch")
mod_one_pos_lpp_rev <- lmerTest::lmer(LPP ~ block + (1|pid), data = per_erp_rev)
summary(mod_one_pos_lpp_rev)

# front avr
## right side
### relelve for positive watch reference
per_erp_filter_lat$block <- relevel(as.factor(per_erp_filter_lat$block), "Pos_Watch")
mod_one_pos_front_right_avr_fil <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right", prop_trials >= .5))
summary(mod_one_pos_front_right_avr_fil)
### relevel for negative watch reference
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch") 
mod_one_neg_front_right_avr_fil <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
summary(mod_one_neg_front_right_avr_fil)

## for left side
### positive reference
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_one_pos_front_left_avr_fil <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
summary(mod_one_pos_front_left_avr_fil)
## negative reference
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch") 
mod_one_neg_front_left_avr <- lmerTest::lmer(front_avr ~ block + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
summary(mod_one_neg_front_left_avr)
## test lateralization interaction
mod_one_neg_front_avr_fil <- lmerTest::lmer(front_avr ~ block * lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right", "left")))
summary(mod_one_neg_front_avr_fil)
# interaction with positive reference
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_one_pos_front_avr_fil <- lmerTest::lmer(front_avr ~ block * lateralization + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right", "left")))
check_model(mod_one_pos_front_avr_fil, panel = FALSE)
summary(mod_one_pos_front_avr_fil)
# bootstrap
boot <- bootMer(mod_one_pos_front_avr_fil, FUN = fixef, nsim = 100)
boot::boot.ci(boot, type = "stud")
confint.merMod(mod_one_pos_front_avr_fil, parm = "beta_", boot.type = "perc", nsim = 100)
mySumm <- function(x) {
  c(getME(x, "beta"), sigma(x))
}
```

## Aim Two: LPP and Positive Affectivity

Derive contrasts between neutral watch and positive watch conditions and observe relationship between this contrast and positive affectivity, which is in line with the study hypothesis that the LPP contrast between the neutral watch and positive watch conditions will be moderated by positive affectivity

```{r pos affectivity contrasts, message=FALSE}
# function for deriving Wald confidence intervals for robust models
confint.rlmerMod <- function(object,parm,level=0.95) {
  beta <- fixef(object)
  if (missing(parm)) parm <- names(beta)
  se <- sqrt(diag(vcov(object)))
  z <- qnorm((1+level)/2)
  ctab <- cbind(beta-z*se,beta+z*se)
  colnames(ctab) <- stats:::format.perc(c((1-level)/2,(1+level)/2),
                                        digits=3)
  return(ctab[parm,])
}
# relevel block factor
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
# fit model
mod_two_lpp <- lmerTest::lmer(LPP ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
# check assumptions
check_model(mod_two_lpp, panel = FALSE)
summary(mod_two_lpp)
# some influential cases. try robust method for any differences in results
mod_two_lpp_rob <- rlmer(LPP ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
confint.rlmerMod(mod_two_lpp_rob)

# check model two with EPN as outcome
mod_two_epn <- lmerTest::lmer(EPN ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + lateralization + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
check_model(mod_two_epn, panel = FALSE)
summary(mod_two_epn)
# try robust model
mod_two_epn_rob <- rlmer(EPN ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_two_epn_rob)
confint.rlmerMod(mod_two_epn_rob)

# check three-way interaction with lateralization as well
mod_two_epn_lat <- lmerTest::lmer(EPN ~ block * lateralization * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
check_model(mod_two_epn_lat, panel = FALSE)
summary(mod_two_epn_lat)
# robust model
mod_two_epn_lat_rob <- rlmer(EPN ~ block * lateralization * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|lateralization:pid) + (lateralization|pid), data = per_erp_filter_lat)
plot(modmod_two_epn_lat_rob)

# revised LPP selection
per_erp_rev$block <- relevel(per_erp_rev$block, "Neu_Watch")
mod_two_lpp_rev <- lmerTest::lmer(LPP ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_rev)
check_model(mod_two_lpp_rev, panel = FALSE)
summary(mod_two_lpp_rev)
r2beta(mod_two_lpp_rev)
# Is LPP averaged across all conditions related to positive affectivity?
mod_lpp_avg_pa <- lmer(LPP ~ scale(neg_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_rev)
summary(mod_lpp_avg_pa)

# check right frontal component
per_erp_lat$block <- relevel(per_erp_lat$block, "Neg_Watch")
right_pos_mod <- lmerTest::lmer(front_avr ~ block * scale(masq_pa, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_lat %>% filter(lateralization == "left"))
summary(right_pos_mod)

#----- old code, might be useful down the line.
# pos_watch_contrast <- per_erp_int %>% 
#   filter(block == "Neu_Watch") %>%
#   rename("LPP_neu_watch" = LPP) %>% 
#   select(-block)
# 
# tmp <- per_erp_int %>% 
#   filter(block == "Pos_Watch") %>% 
#   rename("LPP_pos_watch" = LPP) %>% 
#   select(pid, LPP_pos_watch)
# 
# pos_watch_contrast <- full_join(pos_watch_contrast, tmp, by = "pid") %>% 
#   mutate(contrast = LPP_pos_watch - LPP_neu_watch)
# 
# ggplot(pos_watch_contrast, aes(pos_affectivity, contrast)) +
#   geom_point() +
#   ggtitle("Positive affectivity and contrast between \nNeutral Watch and Positive Watch")
```

There doesn't appear to be any relationship between the two. We can derive a Pearson Product Moment correlation coefficient between contrasts and positive affectivity to validate this.

## LPP and savoring the  moment

Derive contrasts between positive watch and positive increase conditions and observe relationship between this contrast and savoring the moment, which is in line with the study hypothesis that the LPP contrast between the positive watch and positive increase conditions will be moderated by savoring the moment.

```{r savoring moment contrasts, message=FALSE}
# relevel block variable
per_erp_filter_lat$block <-  relevel(per_erp_filter_lat$block, "Pos_Watch")
per_erp_filter_lat$lateralization <- relevel(per_erp_filter_lat$lateralization, "right")
# model 3
mod_3_lpp <- lmerTest::lmer(LPP ~ block * scale(savoring_moment, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
check_model(mod_3_lpp, panel = FALSE)
summary(mod_3_lpp)
# check robust model
mod_3_lpp_rob <- rlmer(LPP ~ block * scale(savoring_moment, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_3_lpp_rob)
confint.rlmerMod(mod_3_lpp_rob)

# model 3 with EPN
mod_3_epn <- lmerTest::lmer(EPN ~ block * scale(savoring_moment, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
check_model(mod_3_epn)
summary(mod_3_epn)

#robust model
mod_3_epn_rob <- rlmer(EPN ~ block * scale(savoring_moment, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_3_epn_rob)

# revised lpp selection
per_erp_rev$block <-  relevel(per_erp_rev$block, "Pos_Watch")
mod_3_lpp_rev <- lmerTest::lmer(LPP ~ block * scale(savoring_moment, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_rev)
check_model(mod_3_lpp_rev, panel = FALSE)
summary(mod_3_lpp_rev)

# frontal component
per_erp_filter_lat$block <-  relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_3_front <- lmerTest::lmer(front_avr ~ block * scale(pos_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
check_model(mod_3_front, panel = FALSE)
summary(mod_3_front)

# test neg affectivity as moderator betwee negative regulation blocks
per_erp_lat$block <-  relevel(per_erp_lat$block, "Neg_Watch")
per_erp_filter_lat$block <-  relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_front_neg_affect <- lmerTest::lmer(front_avr ~ block * scale(neg_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
check_model(mod_front_neg_affect, panel = FALSE)
summary(mod_front_neg_affect)
mod_front_neg_rob <- rlmer(front_avr ~ block * scale(neg_affectivity, center = TRUE, scale = FALSE) + (1|pid), data = per_erp_lat %>% filter(lateralization == "left"))
confint.rlmerMod(mod_front_neg_rob)

#---- old code
# pos_inc_contrast <- per_erp_int %>% 
#   filter(block == "Pos_Watch") %>%
#   rename("LPP_pos_watch" = LPP) %>% 
#   select(-block)
# 
# tmp <- per_erp_int %>% 
#   filter(block == "Pos_Inc") %>% 
#   rename("LPP_pos_inc" = LPP) %>% 
#   select(pid, LPP_pos_inc)
# 
# pos_inc_contrast <- full_join(pos_inc_contrast, tmp, by = "pid") %>% 
#   mutate(contrast = LPP_pos_inc - LPP_pos_watch)
# 
# ggplot(pos_inc_contrast, aes(savoring_moment, contrast)) +
#   geom_jitter() +
#   ggtitle("Momentary savoring and contrast between \nPositive Watch and Positive Increase")
```

## EEG and arousal ratings

Scatterplot between EEG components and arousal ratings

```{r arousal ratings and LPP}
# LPP
per_erp_filter_lat %>% 
ggplot(., aes(arousal, LPP, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) +
  ggtitle("Arousal ratings and LPP") +
  geom_smooth(method = "lm", se = FALSE)
# EPN
per_erp_filter_lat %>% 
  ggplot(., aes(arousal, EPN, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) +
  ggtitle("Arousal ratings and EPN") +
  geom_smooth(method = "lm", se = FALSE)
# Centro-parietal LPP
per_erp_rev %>% 
  ggplot(., aes(arousal, LPP)) +
  geom_jitter(width = 0.1, height = 0.1) +$
  ggtitle("Arousal ratings and LPP") +
  geom_smooth(method = "lm", se = FALSE)
# frontal
per_erp_filter_lat %>% 
  filter(lateralization %in% c("right", "left")) %>% 
  ggplot(., aes(arousal, front_avr, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) +
  ggtitle("Arousal ratings and frontal component") +
  geom_smooth(method = "lm", se = FALSE)
```

There appears to be some positive relations. Let's test a linear model using MLM to account for the clustering between participants.

```{r eeg predicted by arousal}
mod_arousal_lpp <- lmerTest::lmer(LPP ~ arousal + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_arousal_lpp)
mod_arousal_lpp_rev <- lmerTest::lmer(LPP ~ arousal + (1|pid), data = per_erp_rev)
summary(mod_arousal_lpp_rev)
mod_arousal_epn <- lmerTest::lmer(EPN ~ arousal + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_arousal_epn)
right_frontal_arousal <- lmerTest::lmer(front_avr ~ arousal + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
summary(right_frontal_arousal)
left_frontal_arousal <- lmerTest::lmer(front_avr ~ arousal + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
summary(left_frontal_arousal)
```

## EEG and valence ratings

Scatterplot between LPP and valence ratings

```{r valence ratings and LPP, warning=FALSE, message=FALSE}
# LPP
per_erp_filter_lat %>% 
  filter(lateralization %in% c("left", "right")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right"))) %>% 
ggplot(., aes(valence, LPP, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(se = FALSE) +
  ggtitle("Valence ratings and LPP")
# EPN
per_erp_filter_lat  %>% 
  filter(lateralization %in% c("left", "right")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right"))) %>%  
ggplot(., aes(valence, EPN, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(se = FALSE) +
  ggtitle("Valence ratings and EPN")
# revised lpp
per_erp_rev %>% 
ggplot(., aes(valence, LPP)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(se = FALSE) +
  ggtitle("Valence ratings and centro-parietal LPP")
# frontal
per_erp_filter_lat %>% 
filter(lateralization %in% c("left", "right")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right"))) %>% 
ggplot(., aes(valence, front_avr, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(se = FALSE) +
  ggtitle("Valence ratings and frontal component")
```

At first glance, there does not appear to be a relationship. However, it is hypothesized that more negatively- and positively-valenced images may positively correlate with LPP. Let's test this by fitting a polynomial regression line through the scatterplot.

```{r, message=FALSE, warning=FALSE}
# LPP
per_erp_filter_lat %>% 
    filter(lateralization %in% c("left", "right")) %>% 
ggplot(., aes(valence, LPP, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  stat_smooth(method = "lm", formula = y ~ poly(x, 2)) +
  ggtitle("Valence ratings and LPP")
# EPN
per_erp_filter_lat %>% 
    filter(lateralization %in% c("left", "right")) %>% 
ggplot(., aes(valence, EPN, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  stat_smooth(method = "lm", formula = y ~ poly(x, 2)) +
  ggtitle("Valence ratings and EPN")
# centro-parietal LPP
per_erp_rev %>% 
ggplot(., aes(valence, LPP)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  stat_smooth(method = "lm", formula = y ~ poly(x, 2)) +
  ggtitle("Valence ratings and LPP")
```

Now, conduct a polynomial regression using MLM.

```{r}
mod_valence_lpp <- lmerTest::lmer(LPP ~ poly(valence, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_valence_lpp)
check_model(mod_valence_lpp, panel = FALSE)
mod_valence_epn <- lmerTest::lmer(EPN ~ poly(valence, 2) * lateralization + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(mod_valence_epn) #---- Three way interaction
mod_valence_lpp_rev <- lmerTest::lmer(LPP ~ poly(valence, 2) + (1|pid), data = per_erp_rev)
summary(mod_valence_lpp_rev)
front_right_valence <- lmerTest::lmer(front_avr ~ poly(valence, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "right"))
summary(front_right_valence)
front_left_valence <- lmerTest::lmer(front_avr ~ poly(valence, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "left"))
summary(front_left_valence)
```

Results indicate that there is a curvilinear relationship between LPP and arousal.

## LPP and difficulty ratings

Scatterplot between LPP and dificulty ratings.

```{r difficulty ratings and LPP, warning=FALSE, message=FALSE}
per_erp_filter_lat %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "avg", "right"))) %>% 
ggplot(., aes(difficulty, LPP, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Difficulty ratings and LPP")
per_erp_filter_lat %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "avg", "right"))) %>% 
ggplot(., aes(difficulty, EPN, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Difficulty ratings and EPN")
per_erp_rev %>%
ggplot(., aes(difficulty, LPP)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Difficulty ratings and centroparietal LPP")
per_erp_filter_lat %>% 
  filter(lateralization %in% c("left", "right")) %>% 
  mutate(lateralization = fct_relevel(lateralization, c("left", "right"))) %>% 
  ggplot(., aes(difficulty, front_avr, color = lateralization)) +
  geom_jitter(width = 0.1, height = 0.1) + 
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle("Difficulty ratings and frontal component")
```

There may be a slight linear relationship, though it is weak. Let's try fitting a linear model to test this.

```{r, warning=FALSE, message=FALSE}
mod_difficulty_lpp <- lmerTest::lmer(LPP ~ difficulty + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
check_model(mod_difficulty_lpp, panel = FALSE)
summary(mod_difficulty_lpp)
mod_difficulty_epn <- lmerTest::lmer(EPN ~ difficulty + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_difficulty_epn)
mod_difficulty_lpp_rev <- lmerTest::lmer(LPP ~ difficulty + (1|pid), data = per_erp_rev)
summary(mod_difficulty_lpp_rev)
mod_difficulty_front_left <- lmerTest::lmer(front_avr ~ difficulty + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left")))
summary(mod_difficulty_front_left)
mod_difficulty_front_right <- lmerTest::lmer(front_avr ~ difficulty + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right")))
summary(mod_difficulty_front_right)
# there is an interaction with Positive increase and difficulty for the left frontal component.
```

There does appear to be a positive relationship between the difficulty of the task and LPP.

## Valence and difficulty ratings

```{r, message=FALSE, warning=FALSE}
per_erp_filter_lat %>% 
  filter(lateralization == "avg") %>% 
ggplot(., aes(valence, difficulty)) +
  geom_jitter(height = 0.2, width = 0.2) + 
  geom_smooth() +
  ggtitle("Valence and difficulty ratings")
```

There doesn't appear to be a relationship between the two, but we can test this.

```{r, message=FALSE, warning=FALSE}
mod_diff_val <- lmerTest::lmer(difficulty ~ valence + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_diff_val)
mod_diff_val_poly <- lmerTest::lmer(difficulty ~ poly(valence, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_diff_val_poly) # the polynomial term is non-significant
```

I stand corrected. There is a relationship. Let's check the effect size:

```{r}
r2beta(mod_diff_val)
```

## Valence and arousal

```{r, message=FALSE, warning=FALSE}
per_erp_filter_lat %>% 
  filter(lateralization == "avg") %>% 
ggplot(., aes(valence, arousal)) +
  geom_jitter(width = 0.3, height = 0.3) + 
  geom_smooth() +
#  geom_smooth(method = "lm") +
 # stat_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red") +
  ggtitle("Valence and arousal ratings")
```

It looks like there is a strong curvilinear relationship between the two. 

```{r, message=FALSE, warning=FALSE}
mod_val_arousal <- lmerTest::lmer(arousal ~ poly(valence, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_val_arousal)
report(mod_val_arousal)
r2beta(mod_val_arousal)
```

The MLM analysis confirms this relationship.

## Arousal and difficulty ratings

```{r, message=FALSE, warning=FALSE}
per_erp_filter_lat %>% 
  filter(lateralization == "avg") %>% 
ggplot(., aes(arousal, difficulty)) +
  geom_jitter(height = 0.3, width = 0.3) + 
  stat_smooth() +
  ggtitle("Arousal and difficulty ratings")
```

There is perhaps a curvilinear relationship. Let's model a locally weighted (green) and polynomial regression (red) line on the plot to see what the relationship is, and how well the polynomial regression line fits compared to the locally weighted one.

```{r, message=FALSE, warning=FALSE}
ggplot(filter(per_erp_filter_lat, lateralization == "avg"), aes(arousal, difficulty)) +
  geom_jitter(height = 0.3, width = 0.3) + 
  geom_smooth(color = "green", alpha = 0.2) +
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red", alpha = 0.2) +
  ggtitle("Arousal and difficulty ratings")
```

It looks like the curvilnear relationship may be a good fit. Let's test it with an MLM analysis

```{r, warning=FALSE, message=FALSE}
mod_diff_arousal <- lmerTest::lmer(difficulty ~ poly(arousal, 2) + (1|pid), data = per_erp_filter_lat %>% filter(lateralization == "avg"))
summary(mod_diff_arousal)
r2beta(mod_diff_arousal)
```

Indeed, the results indicated that the relationship is curvilinear.

Exploration of traits and average EEG components collapsed across all groups.
```{r trait and average eeg exploration}
stm_lpp <- lmerTest::lmer(LPP ~ savoring_moment + lateralization + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(stm_lpp)
pa_lpp <- lmerTest::lmer(LPP ~ pos_affectivity + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right", "left")))
summary(pa_lpp)
stm_epn <- lmerTest::lmer(EPN ~ savoring_moment + lateralization + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(stm_epn)
pa_epn <- lmerTest::lmer(EPN ~ pos_affectivity + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("left", "right")))
summary(pa_epn)
# revised lpp
stm_lpp_rev <- lmerTest::lmer(LPP ~ savoring_moment + (1|pid), data = per_erp_rev)
summary(stm_lpp_rev)
pa_lpp_rev <- lmerTest::lmer(LPP ~ pos_affectivity + (1|pid), data = per_erp_rev)
summary(pa_lpp_rev)
# right front
stm_front <- lmerTest::lmer(front_avr ~ savoring_moment*lateralization + (1|pid), data = per_erp_filter_lat %>%  filter(lateralization %in% c("right", "left")))
summary(stm_front)

stm_right_front <- lmerTest::lmer(front_avr ~ depression + (1|pid), data = per_erp_filter_lat %>% filter(lateralization %in% c("right")))
summary(stm_right_front)
```

# check out arousal/valence predicted by block/personality traits
## CONTINUE WITH THIS SECTION
```{r}
#---- POS_AFFECTIVITY
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
mod_arousal_pa <- lmerTest::lmer(arousal ~ block * pos_affectivity + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_pa)
## interaction between arousal ratings and positive affecitivity
mod_valence_pa <- lmerTest::lmer(valence ~ block * pos_affectivity + (1|pid), data = per_erp_filter_lat)
summary(mod_valence_pa)
## interaction between valence ratings and positive affectivity

#----- SAVORING THE MOMENT
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_arousal_stm <- lmerTest::lmer(arousal ~ block * savoring_moment + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_stm)
mod_arousal_stm <- lmerTest::lmer(valence ~ block * savoring_moment + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_stm)
## no interactions for savoring the moment

#---- DEPRESSION
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
mod_arousal_dep <- lmerTest::lmer(arousal ~ depression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_dep)
# nothing
mod_arousal_dep_block <- lmerTest::lmer(arousal ~ block * depression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_dep_block)
# nothing
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_valence_dep <- lmerTest::lmer(valence ~ depression + (1|pid), data = per_erp_filter_lat)
summary(mod_valence_dep)
mod_valence_dep_block <- lmerTest::lmer(valence ~ block*depression + (1|pid), data = per_erp_filter_lat)
summary(mod_valence_dep_block)
# nothing
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_arousal_dep_block_neg <- lmerTest::lmer(arousal ~ block * depression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_dep_block_neg)

#--- ERQ SUBSCALES - LOOK AT VALENCE TOO
# reappraisal arousal
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_arousal_reappraisal <- lmerTest::lmer(arousal ~ erq_reappraisal + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_reappraisal)
mod_arousal_reappraisal_block <- lmerTest::lmer(arousal ~ block*erq_reappraisal + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Neg_Watch", "Neg_Inc", "Neg_Dec")))
summary(mod_arousal_reappraisal_block)
# nothing here
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_arousal_reappraisal_block_pos <- lmerTest::lmer(arousal ~ block*erq_reappraisal + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Pos_Watch", "Pos_Inc", "Pos_Dec")))
summary(mod_arousal_reappraisal_block_pos)
## interactin for erq with pos_dec vs. watch and arousal
# reappraisal valence
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_valence_reappraisal <- lmerTest::lmer(valence ~ erq_reappraisal + (1|pid), data = per_erp_filter_lat)
summary(mod_valence_reappraisal)
mod_valence_reappraisal_block <- lmerTest::lmer(valence ~ block*erq_reappraisal + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Neg_Watch", "Neg_Inc", "Neg_Dec")))
summary(mod_arousal_reappraisal_block)
# interaction between negative increase and erq suppression - not what would be suspected
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_valence_reappraisal_block_pos <- lmerTest::lmer(valence ~ block*erq_reappraisal + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Pos_Watch", "Pos_Inc", "Pos_Dec")))
summary(mod_valence_reappraisal_block_pos)
# intearction between positive decrease and erq reappraisal
## interactin for erq with pos_dec vs. watch and arousal

# suppression - LOOK AT VALENCE???
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_arousal_reappraisal <- lmerTest::lmer(arousal ~ erq_suppression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_reappraisal)
mod_arousal_reappraisal_block <- lmerTest::lmer(arousal ~ block*erq_suppression + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Neg_Watch", "Neg_Inc", "Neg_Dec")))
summary(mod_arousal_reappraisal_block)
# Interaction between neg inc vs. neg watch and arousal by suppression - doesn't make a whole lot of sense
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_arousal_reappraisal_block_pos <- lmerTest::lmer(arousal ~ block*erq_suppression + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Pos_Watch", "Pos_Inc", "Pos_Dec")))
summary(mod_arousal_reappraisal_block_pos)
# nothing
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_arousal_reappraisal <- lmerTest::lmer(valence ~ erq_suppression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_reappraisal)
mod_arousal_reappraisal_block <- lmerTest::lmer(arousal ~ block*erq_suppression + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Neg_Watch", "Neg_Inc", "Neg_Dec")))
summary(mod_arousal_reappraisal_block)
# Interaction between neg inc vs. neg watch and arousal by suppression - doesn't make a whole lot of sense
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
mod_arousal_reappraisal_block_pos <- lmerTest::lmer(arousal ~ block*erq_suppression + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Pos_Watch", "Pos_Inc", "Pos_Dec")))
summary(mod_arousal_reappraisal_block_pos)
# nothing

## suppression and valence
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
mod_valence_reappraisal <- lmerTest::lmer(valence ~ erq_suppression + (1|pid), data = per_erp_filter_lat)
summary(mod_arousal_reappraisal)
mod_valence_reappraisal_block <- lmerTest::lmer(valence ~ block*erq_suppression + (1|pid), data = filter(per_erp_filter_lat, block %in% c("Neg_Watch", "Neg_Inc", "Neg_Dec")))
summary(mod_valence_reappraisal_block)
# Interaction between neg inc vs. neg watch and arousal by suppression - doesn't make a whole lot of sense

#----- TMMS Subscales
## repair
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
arousal_repair <- lmerTest::lmer(arousal ~ tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(arousal_repair)
# nothing
arousal_repair_block <- lmerTest::lmer(arousal ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(arousal_repair_block)
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
arousal_repair_block_neg <- lmerTest::lmer(arousal ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(arousal_repair_block_neg)
# interactions between TMMS subscale and neg_watch vs. Neg_dec - cool
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
arousal_repair_block_pos <- lmerTest::lmer(arousal ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(arousal_repair_block_pos)
# nothing for positive
# look at valence 
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neu_Watch")
valence_repair <- lmerTest::lmer(valence ~ tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(valence_repair)
# nothing
valence_repair_block <- lmerTest::lmer(valence ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(valence_repair_block)
# interactions between passive watch conditions here
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Neg_Watch")
valence_repair_block_neg <- lmerTest::lmer(valence ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(valence_repair_block_neg)
# interactions here between neg ince vs. neg watch and tmms repair
per_erp_filter_lat$block <- relevel(per_erp_filter_lat$block, "Pos_Watch")
valence_repair_block_pos <- lmerTest::lmer(valence ~ block*tmms_repair + (1|pid), data = per_erp_filter_lat)
summary(valence_repair_block_pos)
# nothing here of interest
## attention
## suppression
```

```{r descriptive statistics}
# sex
per_erp %>% 
  distinct(sex) %>% 
  ungroup() %>% 
  count(sex)

# age
range(per_erp$age)
mean(per_erp$age)
sd(per_erp$age)

# race
per_erp %>% 
  distinct(Race) %>% 
  ungroup() %>% 
  count(Race) %>% 
  mutate(percentage = n / sum(n))

# ethnicity
per_erp %>% 
  distinct(ethnicity) %>% 
  ungroup() %>% 
  count(ethnicity) %>% 
  mutate(percentage = n / sum(n))
```
