---
title: "ERP Visualizations"
author: "Ian Kahrilas"
date: "9/14/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
##Topo plots

load packages recommended at this url:
http://www.mattcraddock.com/blog/2017/02/25/erp-visualization-creating-topographical-scalp-maps-part-1/
```{r packages}
library(tidyverse)
library(akima)
library(scales)
library(mgcv)
library(gridExtra)
library(png)
library(grid)
library(gganimate)
library(gifski)
```
Load in coordinates of our cap
```{r equidistant layout}
elec_loc <- read_csv("Equidistant Layout.csv")
elec_loc <- elec_loc %>%
  rename("channel" = `channel name`) %>%
  filter(channel != "CMS", channel != "DRL")

elec_loc$radian_phi <- pi/180 * elec_loc$phi

elec_loc <- elec_loc %>%
  mutate(x = theta * cos(radian_phi),
         y = theta * sin(radian_phi))

cartesian <- ggplot(elec_loc, aes(x, y, label = channel))+
  geom_text()+
  theme_bw()+
  coord_equal()
```

Define very barebones theme for plotting topo

```{r topo theme}
theme_topo <- function(base_size = 12)
{
  theme_bw(base_size = base_size) %+replace%
    theme(
      rect             = element_blank(),
      line             = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank()
    )
}
```

Create head and nose for plot
```{r head and nose}
circle_fun <- function(center = c(0,0),diameter = 1, npoints = 100) {
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

head_shape <- circle_fun(c(0, 0), diameter = (max(elec_loc$y) + abs(min(elec_loc$y))), npoints = 100)
nose <- data.frame(x = c(-15, 0, 15), y = c(100, 120, 100))
```

Now, here's the head with electrode locations

```{r head with electrode locations}
ggplot(head_shape, aes(x, y)) +
  geom_path()+
  geom_text(data = elec_loc, aes(x, y, label = channel)) +
  geom_line(data = nose, aes(x, y, z = NULL)) +
  theme_topo()+
  coord_equal()
```

Join location data with erp data

```{r join location and erp data}
erp_loc <- left_join(erp_long, elec_loc, by = c("electrode" = "channel"))
```

This defines a MATLAB-style color pallette 

```{r MATLAB colors}
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
```

Test out plot for single condition

```{r test, message = FALSE}
topo_elec <- c(paste0("A", 1:32), paste0("B", 1:32))
single_point <- erp_loc %>% 
  filter(block == "Pos_Watch", between(ms, 300, 800), !is.na(mv), electrode %in% topo_elec) %>%
  group_by(electrode, x, y) %>%
  summarize(mv = mean(mv))

single_point <- erp_loc %>% 
  filter(block == "Pos_Watch", between(ms, 400, 1000), between(mv, -5, 7), !is.na(mv), electrode %in% topo_elec)

p <- ggplot(head_shape, aes(x, y)) +
  geom_path(size = 1.5) +
  geom_point(data = single_point,aes(x, y, color = mv), size = 5) +#note: oob = squish forces everything outside the colour limits to equal nearest colour boundary (i.e. below min colours = min colour)
  scale_color_gradient(jet.colors(10), guide = "colourbar", oob = squish) + 
  geom_line(data = nose,aes(x, y, z = NULL),size = 1.5) +
  theme_topo()+
  coord_equal()

p + labs(title = "Milliseconds: {frame_time}") +
  transition_time(ms) +
  ease_aes("linear")
```

Below code uses GAM approach to topo plot. Looks best for static portrait.
```{r}
grid_res <- 67

ms <- unique(single_point$ms)

spline_smooth <- vector("list", length(ms))

for (i in seq_along((ms))) {
spline_smooth[[i]] <- gam(mv ~ s(x, y, bs = 'ts'), data = filter(single_point, near(ms, ms[i], tol = 1)))
}

GAMtopo <- vector("list", length(ms))

for (i in seq_along(ms)) {
GAMtopo[[i]] <- data.frame(expand.grid(x = seq(min(single_point$x)*2,
                                          max(single_point$x)*2,
                                          length = grid_res),
                                  y = seq(min(single_point$y)*2,
                                          max(single_point$y)*2,                                     
                                          length = grid_res)))
}

for (i in seq_along(ms)) {
GAMtopo[[i]]$mv <-  predict(spline_smooth[[i]], GAMtopo[[i]], type = "response")
GAMtopo[[i]]$ms <- ms[[i]]
}

GAMtopo <- reduce(GAMtopo, bind_rows)

GAMtopo$incircle <- (GAMtopo$x) ^ 2 + (GAMtopo$y) ^ 2 < 135 ^ 2 # mark
GAMtopo_incircle <- GAMtopo %>% filter(incircle == TRUE)

mask_ring <- circle_fun(diameter = 270)

GAMplot <- ggplot(GAMtopo[GAMtopo$incircle,], aes(x, y, fill = mv)) +
  geom_raster() +
  stat_contour(aes(z = mv), binwidth = 0.5) +
  theme_topo() +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-3.5, 3.5),
                       guide = "colourbar",
                       oob = squish) +
  geom_path(data = mask_ring,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 10) +
  geom_point(data = single_point,
             aes(x,y,fill = NULL), size = 1.5)+
  geom_path(data = nose,
            aes(x, y, z = NULL, fill = NULL),
            size = 1.5)+
  geom_path(data = head_shape,
            aes(x,y,z = NULL,fill = NULL),
            size = 1.5) +
  coord_quickmap()
GAMplot
```

Animated topo plot
```{r animated plot}
GAMplot <- ggplot(GAMtopo[GAMtopo$incircle,], aes(x, y, fill = mv)) +
  geom_raster() +
  theme_topo() +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-2, 2),
                       guide = "colourbar",
                       oob = squish) +
  geom_path(data = mask_ring,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 10) +
  geom_point(data = single_point,
             aes(x,y,fill = NULL), size = 1.5)+
  geom_path(data = nose,
            aes(x, y, z = NULL, fill = NULL),
            size = 1.5)+
  geom_path(data = head_shape,
            aes(x,y,z = NULL,fill = NULL),
            size = 1.5) +
  coord_quickmap()

GAMplot + labs(title = "Positive Increase", x = "Milliseconds: {frame_time}") +
  transition_time(ms) +
  ease_aes("linear")
```

#Use this code to select Pz cluster electrodes
Pz_elec <- c(paste("A", 25, sep = ""), paste("B", c(21, 22, 28), sep = ""))

#This is sight of the observed right frontal activity that appears to be maximal at around 1000 ms: B2, B7, & B8
RF_elec <- c(paste0("B", c(2, 7, 8)))

#transpose dataframe to long form for plotting
erp_long <- gather(erp, key = "electrode", value = "mv", str_subset(names(erp), "[A-Z]"))
#convert mv variable to numeric, since it is changed to character class by being coerced with some electrodes
#with all missing values that are interpreted as character
erp_long$mv <- as.numeric(erp_long$mv)

#use this code for LPP average in 300 - 800 ms window
LPP <- erp_long %>%
  filter(!is.na(n_trials), electrode %in% Pz_elec, between(ms, 300, 800)) %>%
  group_by(pid, block, electrode) %>%
  summarize("300_to_800_LPP" = mean(mv))

#find early 0 - 400 ms averages for Pz electroes
LPP_400 <- erp_long %>%
  filter(!is.na(n_trials), electrode %in% Pz_elec, between(ms, 0, 400)) %>%
  group_by(pid, block, electrode) %>%
  summarize("0_to_400_LPP" = mean(mv))

#find 400-1000 ms averages for Pz electrodes - can easily modify to find averages collapsed across electrodes
LPP_1000 <- erp_long %>%
  filter(!is.na(n_trials), electrode %in% Pz_elec, between(ms, 400, 1000)) %>%
  group_by(pid, block, electrode) %>%
  summarize("400_to_1000_LPP" = mean(mv))

#find 1000-2000 ms averages for Pz electrodes - can easily modify to find averages collapsed across electrodes
LPP_2000 <- erp_long %>%
  filter(!is.na(n_trials), electrode %in% Pz_elec, between(ms, 1000, 2000)) %>%
  group_by(pid, block, electrode) %>%
  summarize("1000_to_2000_LPP" = mean(mv))

#find 2000-3000 ms averages for Pz electrodes - can easily modify to find averages collapsed across electrodes
LPP_3000 <- erp_long %>%
  filter(!is.na(n_trials), electrode %in% Pz_elec, between(ms, 2000, 3000)) %>%
  group_by(pid, block, electrode) %>%
  summarize("2000_to_3000_LPP" = mean(mv))


#join all LPP tibbles
LPP_total <- left_join(LPP_400, LPP_1000, by = c("pid", "block", "electrode")) %>%
  left_join(LPP_2000, by = c("pid", "block", "electrode")) %>%
  left_join(LPP_3000, by = c("pid", "block", "electrode"))
  

#Use this for plotting - need to reduce the number of data points here so it doesn't take so long.
avg_erp_long_LPP <- erp_long %>%
  filter(electrode %in% c("B27", "B23")) %>%
  mutate(ms = round(ms, digits = -0.8)) %>%
  group_by(block, ms) %>% 
  summarize(mv = mean(mv, na.rm = TRUE))

avg_erp_long_RF <- erp_long %>%
  filter(electrode %in% RF_elec) %>%
  mutate(ms = round(ms, digits = -0.8)) %>%
  group_by(block, ms) %>% 
  summarize(mv = mean(mv, na.rm = TRUE)) 


####THIS PLOTS ALL BLOCKS for LPP
ggplot(avg_erp_long_LPP, aes(ms, mv, color = block)) +
  geom_line(size = 1) +
  geom_vline(xintercept = 0,linetype = "dashed") +
  geom_vline(xintercept = c(400, 1000), linetype = "solid", color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude (",mu,"V)"))) +
  theme_classic()

ggplot(test, aes(ms, mv)) +
  geom_line(size = 1) +
  geom_vline(xintercept = 0,linetype = "dashed") +
  geom_vline(xintercept = c(400, 1000), linetype = "solid", color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude (",mu,"V)"))) +
  theme_classic()

####This plots all blocks for RF
ggplot(avg_erp_long_RF, aes(ms, mv, color = block)) +
  geom_line(size = 1) +
  geom_vline(xintercept = 0,linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude (",mu,"V)"))) +
  theme_classic()

####THIS PLOTS THE PASSIVE WATCH CONDITIONS
avg_erp_long_LPP %>%
  filter(block %in% c("Neg_Watch",  "Pos_Watch", "Neu_Watch"), ms <= 2000) %>%
  ggplot(., aes(ms, mv, linetype = block)) +
  geom_line(size = 1.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = c(300, 800), linetype = "solid", size = 1.05) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude ( ",mu,"V)"))) +
  theme_classic() +
  theme(axis.title = element_text(size = 16),
        axis.text = element_text(size = 12),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        legend.key.size = unit(2, "line")) + 
  scale_linetype_discrete(name = "Block Condition", 
                          breaks = c("Neg_Watch","Pos_Watch","Neu_Watch"),
                          labels = c("Negative Watch", "Positive Watch", "Neutral Watch")
                          )

avg_erp_long_RF %>%
  filter(block %in% c("Neg_Dec",  "Neg_Inc", "Neg_Watch"), ms <= 2000) %>%
  ggplot(., aes(ms, mv, linetype = block)) +
  geom_line(size = 1.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = c(900, 1100), linetype = "solid", size = 1.05) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude ( ",mu,"V)"))) +
  theme_classic() +
  theme(axis.title = element_text(size = 16),
        axis.text = element_text(size = 12),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        legend.key.size = unit(2, "line")) + 
  scale_linetype_discrete(name = "Block Condition", 
                          breaks = c("Neg_Dec",  "Neg_Inc", "Neg_Watch"),
                          labels = c("Negative Decrease", "Negative Increase", "Negative Watch")
  )
####THIS PLOTS POSITIVE WATCH VS POSITIVE INCREASE
avg_erp_long_LPP %>%
  filter(block %in% c("Pos_Inc",  "Pos_Watch"), ms <= 2000) %>%
  ggplot(., aes(ms, mv, linetype = block)) +
  geom_line(size = 1.1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = c(300, 800), linetype = "solid", size = 1.05) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude ( ",mu,"V)"))) +
  theme_classic() +
  theme(axis.title = element_text(size = 16),
        axis.text = element_text(size = 12),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        legend.key.size = unit(2, "line")) + 
  scale_linetype_discrete(name = "Block Condition", 
                          breaks = c("Pos_Watch", "Pos_Inc"),
                          labels = c("Positive Watch", "Positive Increase")
  )
####This plots RF for positive conditions
avg_erp_long_RF %>%
  filter(block %in% c("Pos_Watch",  "Pos_Inc", "Pos_Dec"), ms <= 2000) %>%
  ggplot(., aes(ms, mv, linetype = block)) +
  geom_line(size = 1) +
  geom_vline(xintercept = 0,linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude (",mu,"V)"))) +
  theme_classic() +
  scale_linetype_discrete(name = "Block Condition", 
                          breaks = c("Pos_Inc", "Pos_Dec", "Pos_Watch"),
                          labels = c("Positive Increase", "Positive Decrease", "Positive Watch")
  ) +
  scale_y_continuous(limits = c(-4.0, 4.0))

####This plots RF for negative conditions
avg_erp_long_RF %>%
  filter(block %in% c("Neg_Watch",  "Neg_Inc", "Neg_Dec"), ms <= 2000) %>%
  ggplot(., aes(ms, mv, linetype = block)) +
  geom_line(size = 1) +
  geom_vline(xintercept = 0,linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(x = "Time (ms)",y = expression(paste("Amplitude (",mu,"V)"))) +
  theme_classic() +
  scale_linetype_discrete(name = "Block Condition", 
                          breaks = c("Neg_Dec", "Neg_Inc", "Neg_Watch"),
                          labels = c("Negative Decrease", "Negative Increase", "Negative Watch")
  ) +
  scale_y_continuous(limits = c(-5.0, 5.0))

####Draft for moderation graph code for pos_affectivity
avg_erp_long %>%
  filter(block = "Pos_Watch") %>%
  mutate(pos_affectivity_level = if_else(pos_affectivity > mean(pos_affectivity) + sd(pos_affectivity, "> +1 SD"), 
                                         if_else(pos_affectivity < mean(pos_affectivity) - sd(pos_affectivity), "< -1 SD", "Average")
                                         )
         ) %>%
  ggplot(., aes(ms, mv), linetype = pos_affectivity_level) +
  geom_line(size = 1)

####Draft for moderation graph code for savoring_moment
ggplot(aes(ms, mv)) +
  geom_line(data = filter(avg_erp_long, block = "Pos_Inc", savoring_moment > savoring_moment + sd(savoring_moment)), size = 1, linetype = "dashed") +
  geom_line(data = filter(avg_erp_long, block = "Pos_Inc", between(savoring_moment, savoring_moment + sd(savoring_moment), savoring_moment - sd(savoring_moment)), size = 1, linetype = "solid")) +
  geom_line(data = filter(avg_erp_long, block = "Pos_Inc", savoring_moment > savoring_moment - sd(savoring_moment)), size = 1, linetype = "dotted")



#some more plotting examining differences in LPP stages
LPP_total_long <- LPP_total %>%
  gather(key = "LPP_stage", value = "mv", str_subset(names(LPP_total), "LPP")) #convert LPP_total to long form for plotting



LPP_total_long %>%
  group_by(block, LPP_stage) %>%
  summarize(mv = mean(mv, na.rm = TRUE)) %>%
ggplot(., aes(LPP_stage, mv)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~ block)